<!DOCTYPE html>
<html lang="de">
<head> 
<meta charset="UTF-8">
<title> XML Checker</title>
<style>
   /* ------------------------------
     Allgemeine Stile für die Seite
  ------------------------------ */
  body { 
        font-family: Arial, sans-serif; /* Schriftart für die ganze Seite */
        margin: 0;                         /* Standardabstand entfernen */
        height: 100%;                     /* Body soll die volle Höhe einnehmen */
        background-color: #f0f0f0;        /* Heller Hintergrund */
  }
  .container {
      display: flex;            /* Flexbox aktivieren */
      justify-content: center;  /* horizontal zentrieren */
      align-items: center;      /* vertikal zentrieren */
      height: 100vh;            /* Container nimmt ganze Höhe ein */
      text-align: center;       /* Text zentrieren */
      flex-direction: column;   /* Elemente untereinander anordnen */ 
      padding-top: 20px;        /* Abstand oben */ 
    }
   
   .logo {
      display: block; 
      max-width: 180px;             /* Logo-Größe passend */
      height: auto;
      margin: 0 auto 20px auto;      /* unten Abstand */
   }
   
  .content {
     background-color: white;
     padding: 40px;
     border-radius: 10px;
     box-shadow: 0 4px 8px rgba(0,0,0,0.2);
     width: 90%;
     max-width: 600px;
     text-align: center;
     flex-grow: 1;                 /* Content kann wachsen */
     display: flex;
     flex-direction: column;
     justify-content: center;      /* vertikal zentrieren innerhalb der Content-Box */
  }
   
  h1 {
     color: #333;              /* Dunkelgraue Schriftfarbe */
     margin-bottom: 20px;        /* Abstand unterhalb der Überschrift */
    }
   
  p {
     color: #666;
    }
  #output { 
    white-space: pre-wrap;      /* Zeilenumbrüche und Leerzeichen bleiben erhalten */
    background: #f5f5f5;        /* Heller Hintergrund für Output */
    padding: 1em;               /* Innenabstand */
    border-radius: 6px;         /* Abgerundete Ecken */ 
  }
  /* ------------------------------
     Fehler-Markierung
  ------------------------------ */
  .error { color: red;
          font-weight: bold; }
</style>
</head>
<body>
  <div class="container">
     <!-- Logo oben --> 
      <img class = "logo" src="https://static.wixstatic.com/media/60bd57_5b977673c14545a48c41a3a8c2fb94e6~mv2.png/v1/fill/w_180,h_130,fp_0.47_0.42,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/Falcos_Logo_BottomText.png"
         alt="Firmenlogo von der Falcos GmbH">
   <div class="content">
     <h1>XML Unicode Checker</h1>
     <p>Lade eine XML-Datei hoch, um sie zu prüfen:</p>
     <pre id="output">Noch keine Datei geprüft.</pre>
     <input type="file" id="fileInput" accept=".xml" />
  </div>
  <div>    
<script>

  
/* ------------------------------
   Regulärer Ausdruck für erlaubte Unicode-Zeichen
   STRLTN = alle erlaubten Zeichen
------------------------------ */
const STRLTN = /(([\t-\n\r -~¡-¬®-ćĊ-ěĞ-ģĦ-ıĴ-śŞ-ūŮ-žƏƠ-ơƯ-ưƷǍ-ǔǞ-ǟǤ-ǰǴ-ǵǺ-ǿȘ-țȞ-ȟȪ-ȫȮ-ȳəʒḂ-ḃḊ-ḋḐ-ḑḞ-ḡḤ-ḧḰ-ḱṀ-ṁṄ-ṅṖ-ṗṠ-ṣṪ-ṫẀ-ẅẌ-ẓẞẠ-ầẪ-ẬẮ-ềỄ-ồỖ-ờỤ-ỹ€])|(M̂|N̂|m̂|n̂|D̂|d̂|J̌|L̂|l̂))*/g;

/* ------------------------------
   Funktion zum Prüfen des Textes
   - text: der zu prüfende Text
   - path: XML-Pfad für die Fehlermeldung
   - output: Array zum Sammeln der Ergebnisse
------------------------------ */
function validateText(text, path, output) {
  // Entferne erlaubte Zeichen, übrig bleiben Fehler
  const fault = text.replace(STRLTN, "");
  // Wenn Fehler gefunden 
  if (fault.length > 0) {
    const uniqueFaults = [...new Set(fault)]; // Nur einmal pro Zeichen
    let marked = text;
  // Jedes verbotene Zeichen rot markieren
    for (const char of uniqueFaults) {
      marked = marked.replaceAll(char, `>>>${char}<<<`);
    }
  // Fehlermeldung vorbereiten  
    const faultCodes = uniqueFaults.map(c => "0x" + c.charCodeAt(0).toString(16));
    output.push(
      `❌ FEHLER in Element ${path}\nText: ${marked}\nverbotene unicode Zeichen: ${faultCodes.join(", ")}\n`
    );
  }
}

/* ------------------------------
   Funktion, die alle XML-Elemente rekursiv durchläuft
   - element: aktuelles XML-Element
   - currentPath: Pfad für Fehlermeldungen
   - output: Array für Ergebnisse
------------------------------ */
function iterChildren(element, currentPath, output) {
  const tag = element.tagName;
  let tagText = tag;

  // Versuche, einen sprechenden Namen aus Unterelementen zu holen
  const idNode = element.querySelector(":scope > id, :scope > identifikation > id, :scope > name");
  if (idNode && idNode.textContent.trim()) {
    tagText = idNode.textContent.trim();
  }
 // Pfad zum aktuellen Element
  const path = currentPath ? `${currentPath}/${tagText}` : tagText;
 // Text im aktuellen Element
  const text = element.childNodes.length === 1 && element.firstChild.nodeType === Node.TEXT_NODE
    ? element.textContent.trim()
    : "";

  if (text) {
    validateText(text, path, output); // Text prüfen
  }
// Rekursiv alle Kinder prüfen
  for (const child of element.children) {
    iterChildren(child, path, output);
  }
}

/* ------------------------------
   Event Listener für Datei-Upload
------------------------------ */
document.getElementById("fileInput").addEventListener("change", event => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    const xmlString = e.target.result;
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "application/xml");

    const output = [];

    // Prüfen, ob Parsing erfolgreich war
    if (xmlDoc.querySelector("parsererror")) {
      output.push("❌ Fehler: XML konnte nicht gelesen werden!");
    } else {
      output.push("--- STARTING ITERATION ---\n");
      iterChildren(xmlDoc.documentElement, "", output);
      output.push("\n--- FINISHED ITERATION ---");
    }
   // Ergebnisse in HTML ausgeben (rot markierte Zeichen werden angezeigt)
    document.getElementById("output").textContent = output.join("\n\n");
  };
  reader.readAsText(file, "utf-8");
});
</script>

</body>
</html>
